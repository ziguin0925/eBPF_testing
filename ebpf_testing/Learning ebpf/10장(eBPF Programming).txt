bpftrace 스크립트는 BCC 프로그램으로 변환된 다음 LLVM/Clang 툴체인을 사용하여 런타임에 컴파일된다.


eBPF 기반 성능 측정을 위한 명령줄 도구를 원하는 경우 bpftrace를 사용하면 요구 사항이 충족될 수 있습니다.
그러나 bpftrace는 추적을 위해 eBPF를 사용하는 강력한 도구일 수 있지만 eBPF가 지원하는 모든 가능성을 열어주지는 않습니다.


iovisor
/
bpftrace

-------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------커널에서 eBPF에 대한 언어-----------------------------------------------

대부분 C 또는 Rust에서 바이트코드로 컴파일


언어에 런타임 구성요소(Go 또는 Java의 가상 머신)가 포함된 경우 eBPF 검증기와 호환되지 않을 가능성이 높다.



 eBPF 프로그램은 단일 스레드여야 하므로 언어의 동시성 기능을 사용할 수 없습니다.




C로 커널 측 코드를 작성하기로 선택한 사람들은 C로 사용자 공간 코드를 작성할 수도 있습니다.

그러나 C는 프로그래머가 스스로 많은 세부 사항, 특히 메모리 관리를 처리해야 하는 매우 낮은 수준의 언어입니다.
시스템 호출 인터페이스에 직접 작성할 필요가 없도록 eBPF 지원을 제공하는 라이브러리가 필요합니다.





----------------------------------------------------BCC이용 
파이썬 튜토리얼
https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md
(위의 튜토리얼은 bcc(?) 프레임워크에서 자체 파이썬 eBPF 도구를 개발하는 데 도움이 됨.)


5장 에는 이식성에 대한 BCC의 접근 방식에 대한 논의가 포함되어있다.
이는 eBPF 코드를 런타임에 컴파일하여 대상 시스템의 커널 데이터 구조와 호환되도록하는 것이다.

. BCC에서는 커널 측 eBPF 프로그램 코드를 문자열(또는 BCC가 문자열로 읽는 파일의 내용)로 정의하고,
 이 문자열을 컴파일하기 전에 BCC가 문자열에 대해 일부 전처리를 수행한다.
		(  문자열 = (program = "... ") 이부분인듯.  )

이 문자열은 컴파일을 위해 Clang으로 전달 되기 전에,  BCC가 문자열( string)에 대해 일부 사전 처리를 수행합니다
 Chapter2/hello_map.py에서
# b["output"].open_ring_buffer(print_event)부분이 있다.
이부분은 객체 파일에서 쓰이는 ringbuf_output()와 같아 보인다.


b["output"].open_ring_buffer(print_event)이것은 c언어의 일부가 아니다.
bcc는 이 문장을 구현하기 위해 무거운 작업을 수행한다.(?)
https://github.com/iovisor/bcc/blob/14c5f99750cca211cbc620910ac574bb43f58d1d/src/cc/frontends/clang/b_frontend_action.cc#L959

이 코드에서는 "output"이라는 링 버퍼를 정의하는 다른 위치가 없지만 여기서는 Python 사용자 공간 코드에서 액세스할 수 있습니다. BCC는 callout 3의 라인을 전처리할 때 사용자 공간 및 커널 부분 모두에 대한 링 버퍼를 정의하는 데 이중 역할을 합니다.(p.211 의 6번)

즉 #BPF_RINGBUF_OUTPUT(output, 1); 을 처리할 때 사용자 공간과 커널 부분에 링버퍼를 정의하는 이중역할을 한다.


BCC는 BPF 프로그래밍을 위한 C와 유사한 언어를 제공.
프로그래머를 위해 공유 구조 정의 및 BPF 헬퍼 함수를 감싸는 편리한 단축키와 같은 작업을 처리하여 쉽게 사용할 수 있게 해줍니다.
BCC는 새로운 사용자에게 eBPF 프로그래밍에 진입하기에 접근성이 좋은 방법이다.






 BCC는 eBPF 도구의 사용자 공간 부분에 대한 언어로 Python뿐만 아니라Lua,C++에서 도구 작성을 가능하게 한다.

 유틸리티와 함께 컴파일러 도구 체인을 배포하는 것의 비효율성때문에 다른 라이브러리를 사용하는것을 추천.

-------------------------------------------------------------------------------------------------------------------------





---------------------------------------------C와 Libbpf----------------------------------------------------------------------


책에서 LLVM 툴체인을 사용하여 eBPF 바이트코드로 컴파일하는 C로 작성된 eBPF 프로그램에 대한 많은 예제를 보았다.
 BTF 및 CO-RE를 지원하기 위해 확장이 추가됨.



CO-RE와 libbpf를 사용하면  이식 가능한 eBPF 프로그래밍에 대한 접근 방식이 가능하다.
컴파일러 및 eBPF도구를 제공 안해도됨.
 일반적인 합의는 libbpf를 기반으로 재작성된 BCC 도구 버전이 사용하기에 더 나은 옵션이라는 것입니다.
 이유는 메모리 사용량이 상당히 적고 컴파일하는 동안 시작 지연이 발생하지 않기 때문입니다.
c프로그래밍에 익숙하다면 libbpf를 사용하는것이 좋다.




https://github.com/libbpf/libbpf-bootstrap 

c로 eBPF프로그램 작성하기 좋은 예제.





libxdp  라이브러리 : XDP 프로그램을 더 쉽게 개발하고 관리할 수 있도록
(          https://github.com/xdp-project/xdp-tutorial         )




. C 프로그래머는 메모리 관리나 버퍼 처리 같은 일을 책임져야 하며,
잘못된 포인터 처리로 인한 충돌은 말할 것도 없고 보안 취약점이 있는 코드를 작성하게 되기가 매우 쉽다.

eBPF 검증자는 커널 측에서 도움을 주지만 사용자 공간 코드에 대해서는 도움을 주지 못한다.


 libbpf와 인터페이스하거나 이식 가능한 eBPF 프로그램을 허용하는 유사한 재배치 기능을 제공하는 다른 프로그래밍 언어용 라이브러리가 있다.


p.212 밑에부터




Go를 이용한 gobpf, eBPF-go, libbpfgo

GObpf 최근에 유지보수 되고있지 않는중.




-------------------------------eBPF-go cilium 프로젝트의 일부. co-re지원

bpf2go도구 : eBPF프로그램 바이트 코드로 컴파일 , 해당 바이트 코드를 go소스에 삽입 가능(LLVM, Clang 필요) - > rebuild (ELF)

	rebuild된 객체 파일 로드 및 관리 = main.go
	
c -> (bpf2go)->go(스켈레톤과 같은, 빅 엔디안과 리틀 엔디안 두가지 버전으로 2개 생성) go파일 2개 와 o파일 2개 자동 생성. -> main go에서 활용

go 파일 : o파일에 의해 생성된 스켈레톤 코드와 같은 코드 파일

o 파일 : 빅 엔디안과 리틀 엔디안 두가지 버전 ebpf 파일 바이트 코드

fentry 이벤트뿐만 아니라 XDP 및 cgroup 소켓 연결과 같은 광범위한 네트워크 프로그램 유형 세트를 포함하여 추적을 위한 성능 이벤트를 지원

bpf2go는 eBPF 객체를 조작하기 위한 스켈레톤 코드를 생성(사용자 공간 코드 최소화)


go에서 c(ebpf)연결 가능


-------------------------------------Libbpfgo

libbpf의 C주위에 Go 래퍼를 구현
libbpf를 기반으로 구축되었기 때문에 CO-RE지원

c언어로 작성된 eBPF파일 객체파일을 그대로 go에서 로드
libbpf의 API사용

libbpf C 코드와 Go 사이의 CGo 경계로, 이로 인해 성능 및 기타 문제가 발생 가능.

-----------------------------------------------------------------------------------------------------------------------


Rust를 이용한 Libbpf-rs, Redbpf, Aya, Rust-bcc



 Rust는 eBPF 바이트코드로 컴파일될 수 있다.
즉 사용자 공간과 커널공간을 rust로 작성 가능.


----------------------------------------------Libbpf-rs
libbpfgo와 같음

 libbpf C 코드 주위에 Rust 래퍼를 제공하므로 Rust에서 eBPF 코드의 사용자 공간 부분을 작성가능 
ebpf 커널 소스 코드는 c로 작성됨.





--------------------------------------------------Redbpf


libbpf와 상호작용하는 rust

rust보다 c ebpf 바이트 코드를 컴파일 하는 능력이 좋다.
즉 rust에서  LLVM 식 bitcode로 컴파일한 후 LLVM toolchain을 이용하여 ELF eBPF바이트 코드를 생성.






-------------------------------------------------Aya

Rust compiler rustc는 eBPF 바이트코드를 직접 생성하는 기능을 이용해 Aya프로젝트에 사용. 

직접적으로 syscall을 사용하는 레벨. libbpf에 의존하지 않음.(bcc, llvm 의존 x)

하지만 libbpf가 하는것처럼 btf 형식을 사용함.(데이터 재배치) 즉 한 번 컴파일하고 다른 커널에서 실행할 수 있는 동일한 CO-RE 기능을 제공
Redbpf보다 더 넓은 범위의 eBPF 프로그램 유형을 지원

사용자 공간과 커널공간을 rust로 작성 가능.

aya-tool이라는 것을 통해 커널 데이터 구조에 맞는 rust 구조 정의를 생성.

Aya가 Clang 대신 Rust 컴파일러를 사용하여 해당 ebpf elf 파일을 생성





----------------------------------------------------------------------------------------------------------------------------------






-------------------------------------------------------Testing BPF Programs------------------------------------------------------

bpf() 명령인 BPF_PROG_RUN 이 있습니다 . 테스트 목적으로 사용자 공간에서 eBPF 프로그램을 실행할 수 있습니다.
현재까지는 BPF_PROG_RUN은 대부분 네트워킹과 관련된 BPF 프로그램 유형의 하위 집합에서만 작동합니다.


	$ sysctl -w kernel.bpf_stats_enabled=1

일부 내장된 통계 정보를 사용하여 eBPF 프로그램 성능에 대한 정보를 얻는다.

위의 명령어를 친 후에 

	$ bpftool prog list 를 입력하면 추가 정보가 표시된다.
{
	...
	run_time_ns 316876 run_cnt 4 
	...
}
추가 통계는 굵게 표시되어 있으며 여기서는 프로그램이 4번 실행되어 총 약 300마이크로초가 소요되었음을 보여줍니다









---------------------------------------------------------------------------------------------------------------------------






------------------------------------------------------여러 eBPF 프로그램------------------------------------------------------
eBPF 프로그램은 커널의 이벤트에 연결된 함수이다.
많은 애플리케이션은 목표를 달성하기 위해 둘 이상의 이벤트를 추적(연결)해야 합니다


위 예제로는  초반부에서 이 버전의 bpftrace를 다룬 opensnoop 이며,
 BPF 프로그램을 네 가지 다른 syscall 추적점에 연결하는 것을 보았습니다.















